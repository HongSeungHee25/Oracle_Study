# 1. 데이터 모델링 정의(Data Modeling)
: **기업의 정보 구조를 실체(Entity)와 관계(Relation)를 중심으로 명확하고 체계적으로 표현하여 문서화하는 기법을 말한다.** 
+ 현실 세계의 데이터를 데이터베이스로 구축하기 위한 과정
+ 업무에 필요한 데이터 요구사항을 정의하고 분석하여, 간결하고 알기 쉽게 표현하는 과정

# 2. 데이터 모델링 목적
1. 연관 조직의 **정보요구에 대한 정확한 이해** 를 할 수 있다.
2. **사용자, 설계자, 개발자 간에 효율적인 의사소통 수단** 을 제공한다.
3. 데이터 체계 구축을 통한 **고품질 S/W 와 유지보수 비용의 감소효과** 를 기대할 수 있다.
4. **신규 또는 개선 시스템의 개발 기초** 를 제공한다.

# 3. 데이터 모델링 특성
1. **데이터 중심 분석** 을 통한 **업무 흐름 파악이 용이** 하다.
2. **데이터 무결성을 보장** 할 수 있다.
3. **데이터의 공유를 통한 중복을 제거 하고 일관성 있는 정보를 제공** 받을 수 있다.

# 데이터 모델링 절차
데이터 모델링은 **개념 모델링** => **논리 모델링** => **물리 모델링** 을 통해 **데이터베이스를 구축하는 일련의 절차를 거쳐 진행된다.** 또한, 필요지식 중 **물리 데이터 모델링은 논리 모델을 적용하고자 하는 기술에 맞도록 상세화해 가는 과정입니다.**

# 오라클 데이터 유형
1. **CHAR** : **고정길이** 문자열 DATA 최대 **2000바이트(Byte)** 까지 저장 가능
2. **VARCHAR2** : **가변길이** 문자열 DATA 최대 **4000바이트(Byte)** 까지 저장 가능
3. **NUMBER** : **38 자릿수** 의 숫자 저장가능
4. **DATE** : 날짜 값 저장
5. **BLOB**, **CLOB** : **Binary, Text Data** 최대 **4GB** 까지 저장 가능
    + **BLOB** (Binary Large Object): BLOB은 **2진 데이터, 즉 이미지, 동영상, 사운드 파일 등과 같은 이진 형식의 데이터를 저장하는 데 사용됩니다.** BLOB 열은 데이터베이스 내부에서 바이너리 형태로 저장되며, 일반적으로 파일 첨부, 멀티미디어 데이터, 바이너리 데이터 등을 저장하는 데 활용됩니다. BLOB 데이터는 크기가 크고 이진 형태이기 때문에 텍스트 데이터와는 다르게 색인화되지 않으며, 검색 및 분석 작업에는 특별한 처리가 필요합니다.
    + **CLOB** (Character Large Object): CLOB은 **텍스트 데이터, 즉 긴 문자열 데이터를 저장하는 데 사용됩니다.** CLOB 열은 데이터베이스 내부에서 문자 데이터로 저장되며, 일반적으로 긴 문서, HTML 페이지, XML 데이터, 대용량 문자열 등을 저장하는 데 활용됩니다. CLOB은 대부분의 문자 인코딩 방식을 지원하며, 대용량의 텍스트 데이터를 저장할 수 있습니다.

# 제약 조건 - Delete Constraint
: 참조된 기본키의 값이 삭제될 경우의 처리내용을 정의한다.
1. **Casecade** : 참조한 테이블에 있는 외부키와 일치하는 모든 Row 가 삭제된다.
2. **Restricted** : 참조한 테이블에 있는 외부키에 없는 것만 삭제 가능하다.
3. **Nullify** : 참조한 테이블에 정의된 외부키와 일치하는 것을 Null 로 수정한다.(해당 컬럼이 Null을 허용할 경우만)

# 오라클 무결성(Integrity)에 대한 정의
▶ **무결성이란 데이터의 정확성과 일관성을 보장하며 잘못된 데이터에 입력이나 수정으로부터 데이터베이스를 보호하는 개념이다.** 

# JDBC 에서 오라클 저장프로시저 실행 방법(중요 객체)
+ 저장 프로시저를 호출하기 위해 CallableStatement 객체를 준비합니다. Connection.prepareCall() 메서드를 사용하여 **CallableStatement** 를 생성합니다. 프로시저 호출 구문은 **{ call 프로시저이름(매개변수1, 매개변수2, ...) }** 형태로 작성합니다.

        String sql = "{ call max_custom(?,?) }";	//저장 프로시저 max_custom 호출 sql. {} 안에서 호출하기
        CallableStatement cstmt = conn.prepareCall(sql);	
	    //prepareCall는 저장프로시저 실행하지 위한 객체 생성 메소드
    
+ 매개변수 인덱스, 오라클 데이터 타입 지정

        cstmt.registerOutParameter(1, Types.VARCHAR);	
	    cstmt.registerOutParameter(2, Types.NUMERIC);

+  저장 프로시저의 실행 결과에 따라 결과를 처리합니다. 프로시저가 반환하는 값이나 출력 매개변수가 있는 경우 **getXxx()** 메서드를 사용하여 결과를 가져올 수 있습니다.

        System.out.println("가장 많은 구매 수량으로 제품을 구입한 고객 정보");
	    System.out.println("고객 성명 : "+cstmt.getString(1));		//프로시저 출력값 첫번째 가져오기
	    System.out.println("고객 나이 : "+cstmt.getInt(2));			//프로시저 출력값 두번째 가져오기
        ┗> (1),(2) 은 출력 매개변수의 인덱스입니다.
        ┗> //IN 매개변수가 있으면 cstmt.setXXXX() 메소드로 값을 줍니다.

